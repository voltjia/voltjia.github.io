# 1 + 1 = 2

这不，说到加减乘除，我第一个想到的就是家喻户晓的“1 + 1 = 2”了，那么，如果我们要打印出它来，该怎么做呢？

## 打印字符串

```C
#include <stdio.h>

int main() {
    printf("1 + 1 = 2\n");
    return 0;
}
```

没错，就像刚刚我们打印出“Hello, World!”一样，想要打印出“1 + 1 = 2”，我们很容易就能想出以上方法，直接把原本 `printf` 上的 `"Hello, World!\n"` 替换成 `"1 + 1 = 2\n"` 就行了。照猫画虎并不难，但是大家可能已经在好奇，这样一种被双引号括住的内容，到底是什么。接下来，我们就引入一个新的概念：字符。一个字符可以是一个单独的字母、数字、标点符号等等，在包括 C 语言在内的多数编程语言当中，通常用单引号（`'`）包围，例如 `'a'`、`'0'`、`'!'`。而由字符所组成的一个序列，被称之为字符串，可以是一个词，一个句子，甚至是一整本小说的完整内容（也可以是空的，即没有字符），在包括 C 语言在内的多数编程语言当中，通常用双引号（`"`）包围，例如 `"hello"`、`"12345"`、`"This is a sentence."`。

那么对于真的完全没有接触过编程的读者，可能会有一个疑问，为什么要用引号把它们括起来呢？原因很简单：为了防止字符串内的内容与编程语言本身冲突。打个比方，如果你想要打印出“printf”该怎么办？如果是 `printf(printf);`，那我们该怎么知道里面的 `printf` 不是一个盒子，而是我们要打印的内容呢？如果是 `printf("printf\n");`，就会变得很清晰，我们使用的盒子是 `printf`，输入是 `"printf\n"`。

但是这样的话，就能够完美解决冲突了嘛？还不完全。比如，如果我们想打印出“"hello"”（注意是“"hello"”，而不是“hello”），也就是，如果我们想用字符串来表示双引号这个字符该怎么办？如果我们用 `""hello""`，我们怎么知道在哪个双引号那里停是一个完整的字符串，我们怎么知道这不是要表达 `""`、`hello`、`""`？为了解决这个问题，我们人为地引入一个转义字符，用来改变它后面跟着的字符序列，来表示字符串中的特殊字符，而不是其字面意义，比如 `\"` 就代表了双引号字符，那么我就可以使用 `"\"hello\""` 来表示“"hello"”。眼力好的小伙伴，可能已经发现了，之前的 `"Hello, World!\n` 和 `"1 + 1 = 2\n` 的末尾，都有一个 `\n`，没错，它也是一个转义字符，意思是换行。接下来我们对比一下两段代码，就可以很容易地理解它的作用了。

```C
#include <stdio.h>

int main() {
    printf("Hello, World!");
    printf("Hello, World!");
    return 0;
}
```

如果我们运行以上的代码，会打印出如下内容：

```
Hello, World!Hello, World!
```

可以看到，我们连续触发了两个 `printf`，但是打印在了同一行，这是因为 `printf` 本身并不会默认换行（这也挺好解释的，不然如果你本来不想换行咋办，总得有这么个东西默认不换行）。

```C
#include <stdio.h>

int main() {
    printf("Hello, World!\n");
    printf("Hello, World!\n");
    return 0;
}
```

```
Hello, World!
Hello, World!
```

而如果我们这样写，加入了 `\n`，就能够看到分了两行打印。等等，但现在又有了一个新问题：假如我们想打印的就是“\n”怎么办？如果这个时候它一整个被当成了换行，那岂不是就无法打印了？没错，所以说还有一个转义字符 `\\`，意思是只把 `\\` 看成是一个“\”，不再对后续的字符产生影响，这就防止了我们有时候可能不想要进行转义却被迫转义。

```C
#include <stdio.h>

int main() {
    printf("Hello, World!\\n");
    printf("Hello, World!\n");
    return 0;
}
```

```
Hello, World!\nHello, World!
```

这样，我们就可以打印出“\n”了，也就解决了字符串和转义字符所带来的一些冲突。类似 `\"`、`\n`、`\\` 这样的转义字符还有一些，但是这些内容对于一个初学者来说已经不少了，剩下的在之后的实际使用当中，我们边接触边学就好，毕竟不能一口气吃成一个胖子。

## 打印格式化字符串

```C
#include <stdio.h>

int main() {
    printf("1 + 1 = %d\n", 2);
    return 0;
}
```

第二种方式看上去与第一种差不多，有了微微的调整，大家可以发现 `2` 从字符串中被拿了出来，放在了 `printf` 的后方，取而代之的，是 `%d`，这其实才是 `printf` 函数名真正的含义：“print formatted”。即便是英文很好的初学者，一开始可能也会以为 `printf` 是“print function”的缩写，但其实不然，它真正的用途，其实是打印格式化了的字符串。那么什么叫格式化呢？比如 `"1 + 1 = 2"`，它就是一串没有格式的字符串，它里面的内容，也是静态的，不会根据程序的内容改变而改变，所以你任何时候打印它，结果都应该相同。但是 `"1 + 1 = %d"` 对于 `printf` 这个盒子来说就不一样了，`printf` 会注意到里面存在的占位符（在这里就是 `%d`），并且把它替换成后面对应的数据。这就意味着，我们不仅可以在盒子上放上结果 `2`，我们还可以放上算术表达式，也就是 `1 + 1`，这样程序就可以帮我们运算。

```C
#include <stdio.h>

int main() {
    printf("1 + 1 = %d\n", 1 + 1);
    return 0;
}
```

那有的读者可能就会说了，我既然能写成 `"1 + 1 = 2"`，我为什么非要用格式化的形式，还把 `2` 拆成了 `1 + 1`，这不是脱裤子放屁吗？非也非也，对于“1 + 1 = 2”这种众所周知的常识，当然没有问题了，但假设想让大家打印的是“3.1415926 * 2.71828 = ?”，其中“?”代表运算结果，难道大家还要先拿个计算器算一把？那我是不是就可以写成以下形式，就方便多了？

```C
#include <stdio.h>

int main() {
    printf("3.1415926 * 2.71828 = %f\n", 3.1415926 * 2.71828);
    return 0;
}
```

```
3.1415926 * 2.71828 = 8.539728
```

除此之外，我们以上所写的程序，讲的基本上都是输出，都是可以提前明确知道运行结果的，但是如果输入是在程序运行的时候才被动态提供的呢？那样就更得使用格式化字符串来进行输出了。所以下一个部分，我们就会开始讲解一般在 C 语言中如何进行输入。在此之前，细心的读者可能已经注意到了，我们上面出现了两种占位符：`%d` 和 `%f`。这是为什么呢？原因是它们所对应的数据类型不同，这里我们先不做详细介绍，大家可以先认为，这是整数和小数之间的差别就好。和转义字符类似，为了防止开发者就是想打印“%d”，我们可以使用 `%%` 来转义它。效果参考之前的 `\\` 就好。还有其它各式各样的占位符，大家以后就像转义字符那样，边接触边学就好。

```C
#include <stdio.h>

int main() {
    int a = 1;
    int b = 1;
    printf("1 + 1 = %d\n", a + b);
    return 0;
}
```

在打印格式化字符串的基础上，我们还可以有这第三种方式，效果与之前两种相同。之所以写出这种方式，是因为如此我们就可以方便地引入一个新的概念：变量。想象一下，你在家中有一个抽屉，你经常将日常用品放入这个抽屉。有时它可能存放钱包，有时是遥控器，有时是笔和纸。这个抽屉的内容会根据你的需要而变化，但这个抽屉的位置和名称始终保持不变。在编程世界中，这个抽屉就是变量。

不同的编程语言，声明这样的一个抽屉的方式也有所不同，但是一般最起码得需要一个名称，在 C 语言当中，你还得明确地在抽屉上注明它里面东西的种类，以此来区分不同种类的抽屉。比如 `int a;`，这样一行代码，就声明了一个叫做 `a` 的抽屉，里面存的内容是 `int`。那么之后你每次提到 `a`，就是找到这个对应的抽屉放东西或者取东西。而类似 `int` 这种抽屉里东西的种类，就叫做类型。在讲解更底层的计算机知识之前，大家不用过分深究，只需要记得 `int` 是英文 integer 的缩写，意思是整数类型，只不过这种抽屉能够存储的整数是有一定范围的，太大或者太小的都放不下（抽屉嘛，总是会满的），不过现在咱们作为初学者能接触到的，先假定不会超出这个范围就好。需要注意的是，声明只是先随便选了个放 `int` 的抽屉，给它命名成了 `a`，但是它里面之前放的是啥，咱不知道，所以就有了另一个操作，叫做初始化，意思很简单，就是在声明之后，明确地把一个东西放到抽屉里，比如 `int a = 1;`，就是在声明了一个能装 `int` 的抽屉 `a` 后，把 `1` 放到了 `a` 里面，这样我们就能确定，`a` 里面肯定装着 `1`，而不是 `0` 或者其它什么奇奇怪怪的数。

让我们再次进入想象，想象一个标着 `printf` 的盒子上面，放着两个被加号（也可以当成是个黑盒，反正功能就是触发了以后能算出两个输入的和）连接着的抽屉，一个抽屉 `a`，一个抽屉 `b`。`printf` 被触发之后，发现字符串里面有占位符 `%d`，于是就去后面找一个整型，发现那两个抽屉被加号连着，于是它就触发了加号，加号又从抽屉里拿出来了里面存放着的数据，也就是两个 `1`，然后算出了 `2`，然后喂回了 `printf`，剩下发生的事情就和上面第二种方式完全相同了。
